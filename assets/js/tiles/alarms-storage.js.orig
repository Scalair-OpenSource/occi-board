/*global cloud:true*/
/*global __:true*/
/*global cs:true*/

/**
 * Class: $od.tiles.storage.Alarms
 * This object allow to retrieve and share alarms with all tiles.
 */
$od.tiles.storage.Alarms = $od.tiles.storage.Base.extend({

    init: function (config) {

        this._super(config);

        this.CRITICAL = 'critical';
        this.WARNING = 'warning';
        this.DOWN = 'down';
        this.UNKNOWN = 'unknown';
        this.OK = 'ok';

        /**
         * Variable: hosts
         * Array of alarms for hosts.
         */
        this.hosts = [];

        /**
         * Variable: services
         * Array of alarms for services.
         */
        this.services = [];

    },

    // CSS class to display highest alert level
    getAlarmLevelCss: function (vmStatus) {
        var self = this;
        var alarmLevel;
        switch (vmStatus.toLowerCase()) {
        case self.CRITICAL:
            alarmLevel = 'status-critical';
            break;
        case self.WARNING:
            alarmLevel = 'status-warning';
            break;
        case self.DOWN:
            alarmLevel = 'status-down';
            break;
        case self.UNKNOWN:
            alarmLevel = 'status-unknown';
            break;
        default:
            alarmLevel = 'status-ok';
            break;
        }

        return alarmLevel;
    },

    /**
     * Method: count
     * Returns the total number of alarms.
     */
    count: function (customData) {
        var self = this;

        if (!customData) {
            customData = self;
        }
        return customData.hosts.length + customData.services.length;
    },

    /**
     * Method: getForHost
     * Return the list of alarms for a given host name.
     */
    getForHost: function (hostname, customData) {
        var self = this;

        var result = [];

        if (!customData) {
            customData = self;
        }

        customData.hosts.each(function (a) {
            if (a.hostname === hostname) {
                result.push(a);
            }
        });

        customData.services.each(function (a) {
            if (a.hostname === hostname) {
                result.push(a);
            }
        });

        return result;
    },

    getHighestStatusForHost: function (hostname, customData) {
        var self = this;

        var result = 'normal';

        if (!customData) {
            customData = self;
        }

        var score = 1000;
        customData.hosts.each(function (a) {
            if (a.hostname === hostname && self.getAlarmScore(a) < score) {
                score = self.getAlarmScore(a);
                result = a.state;
            }
        });

        customData.services.each(function (a) {
            if (a.hostname === hostname && self.getAlarmScore(a) < score) {
                score = self.getAlarmScore(a);
                result = a.state;
            }
        });

        return result;
    },

    /**
     * Method: countForHost
     * Return the number of alarms for a given host name. There is also a totalization.
     *
     * Parameters:
     * hostname - The host name to count alarms for. If undefined, then count is for all hosts.
     */
    countForHost: function (hostname, customData) {
        var self = this;

        var result = {
            //~ state: {},
            total: 0
        };

        if (!customData) {
            customData = self;
        }

        customData.hosts.each(function (a) {
            if (hostname === undefined || a.hostname === hostname) {
                result.total++;
                if (a.state) {
                    if (result[a.state.toLowerCase()]) {
                        result[a.state.toLowerCase()]++;
                    }
                    else {
                        result[a.state.toLowerCase()] = 1;
                    }
                }
            }
        });

        customData.services.each(function (a) {
            if (hostname === undefined || a.hostname === hostname) {
                result.total++;
                if (a.state) {
                    if (result[a.state.toLowerCase()]) {
                        result[a.state.toLowerCase()]++;
                    }
                    else {
                        result[a.state.toLowerCase()] = 1;
                    }
                }
            }
        });

        return result;
    },

    /**
     * The higher the severity (in alarm.state) the lower the score. This is useful to sort by ascending scores.
     */
    getAlarmScore: function (alarm) {
        switch (alarm.state.toLowerCase()) {
        case 'down':
            return 10;
        case 'critical':
            return 20;
        case 'warning':
            return 30;
        case 'unknown':
            return 40;
        default:
            return 100;
        }
    },

<<<<<<< HEAD
=======
    /*
     * Load alarms and give it to callback - not stored!
     */
>>>>>>> c788f37e6c493578a8b8215a4bf037bd95b06f98
    getAlarmsVolatile: function (callback) {
        var self = this;

        $.ajax({
            type: 'GET',
            url: '/vmproxy/url',
            dataType: 'json',
            success: function (vmproxy) {

                if (vmproxy && vmproxy.url) {
                    $.ajax({
                        type: 'GET',
                        url: vmproxy.url + '/nagiosalarms',
                        dataType: 'jsonp',
                        data: {
                            id: $od.uid
                        },
                        success: function(json) {
                            callback(false, {
                                hosts: json.AllUnhandledHosts.sortBy(self.getAlarmScore),
                                services: json.AllUnhandledServices.sortBy(self.getAlarmScore)
                            });
                        },
                        error: function(jqhxr, errorText, errorThrown) {
                            callback (__('Supervision service not available!'));
                        }
                    });

                }
                else {
                    callback(__('Insufficient rights!'));
                }

            },
            error: function (jqhxr, errorText, errorThrown) {
                callback(__('Insufficient rights!'));
            }
        });
    },

    /**
     * Method: request
     * Ask the server for alarms. Only the owner of this storage can call this method. If no owner, then the request is executed.
     *
     * Parameters:
     * config.onComplete - Callback when request complete, either successfuly or with error. This is always called.
     * config.onError - Callback if an error occurs. It will be given a parameter with the error message.
     * config.onSuccess - Callback if request succeed.
     */
    request: function (config) {
        var self = this;

        if (self._owner && config.id !== self._owner) {
            if (config.onSuccess) {
                config.onSuccess();
            }
            if (config.onComplete) {
                config.onComplete();
            }
        }
        else {
            $.ajax({
                type: 'GET',
                url: '/vmproxy/url',
                dataType: 'json',
                success: function (vmproxy) {

                    if (vmproxy && vmproxy.url) {
                        $.ajax({
                            type: 'GET',
                            url: vmproxy.url + '/nagiosalarms',
                            dataType: 'jsonp',
                            data: {
                                id: $od.uid
                            },
                            success: function(json) {
                                self.hosts = json.AllUnhandledHosts.sortBy(self.getAlarmScore);
                                self.services = json.AllUnhandledServices.sortBy(self.getAlarmScore);

                                if (config.onSuccess) {
                                    config.onSuccess();
                                }
                                self.registerExec();
                            },
                            error: function(jqhxr, errorText, errorThrown) {
                                if (config.onError) {
                                    config.onError(__('Supervision service not available!'));
                                }
                            },
                            complete: function () {
                                if (config.onComplete) {
                                    config.onComplete();
                                }
                            }
                        });

                    }
                    else {
                        if (config.onError) {
                            config.onError(__('Insufficient rights!'));
                        }
                    }

                },
                error: function (jqhxr, errorText, errorThrown) {
                    if (config.onError) {
                        config.onError(__('Insufficient rights!'));
                    }
                }
            });
        }
    }

});
